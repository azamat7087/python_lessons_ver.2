## Lesson 7

Курс по программированию на языке Python 

**3 слайд**- Объектно-ориентированное программирование

До сих пор наши программы состояли из функций, т.е. блоков выражений, которые мани-
пулируют данными. Это называется процедурно-ориентированным стилем программиро-
вания. Существует и другой способ организации программ: объединять данные и функ-
ционал внутри некоего объекта. Это называется объектно-ориентированной парадигмой
программирования. В большинстве случаев можно ограничиться процедурным програм-
мированием, а при написании большой программы или если решение конкретной зада-
чи того требует, можно переходить к техникам объектно-ориентированного программи-
рования.
Два основных аспекта объектно-ориентированного программирования – классы и объ-
екты. Класс создаёт новый тип, а объекты являются экземплярами класса. Аналогично,
когда мы говорим о «переменных типа int », это означает, что переменные, которые хра-
нят целочисленные значения, являются экземплярами (объектами) класса int .

Объекты могут хранить данные в обычных переменных, которые принадлежат объек-
ту. Переменные, принадлежащие объекту или классу, называют полями. Объекты могут
также обладать функционалом, т.е. иметь функции, принадлежащие классу. Такие функ-
ции принято называть методами класса. Эта терминология важна, так как она помогает
нам отличать независимые функции и переменные от тех, что принадлежат классу или
объекту. Всё вместе (поля и методы) принято называть атрибутами класса.
Поля бывают двух типов: они могут принадлежать каждому отдельному экземпляру объ-
екта класса или всему классу. Они называются переменными экземпляра и перемен-
ными класса соответственно.

Класс создаётся ключевым словом class . Поля и методы класса записываются в блоке
кода с отступом.

**4 слайд** - self

Методы класса имеют одно отличие от обычных функций: они должны иметь дополни-
тельно имя, добавляемое к началу списка параметров. Однако, при вызове метода никако-
го значения этому параметру присваивать не нужно – его укажет Python. Эта переменная
указывает на сам объект экземпляра класса, и по традиции она называется self 2 .
Хотя этому параметру можно дать любое имя, настоятельно рекомендуется использовать
только имя self ; использование любого другого имени не приветствуется. Есть много до-
стоинств использования стандартного имени: во-первых, любой человек, просматриваю-
щий вашу программу, легко узнает его; во-вторых, некоторые специализированные Ин-
тегрированные среды разработки (IDE) изначально рассчитаны на использование self.

Вы, должно быть, удивляетесь, как Python присваивает значение self и почему вам не
нужно указывать это значение самостоятельно. Поясним это на примере. Предположим,
у нас есть класс с именем MyClass и экземпляр этого класса с именем myobject . При
вызове метода этого объекта, например, « myobject.method(arg1, arg2) », Python ав-
томатически превращает это в « MyClass.method(myobject, arg1, arg2) » – в этом и
состоит смысл self .
Это также означает, что если какой-либо метод не принимает аргументов, у него всё равно
будет один аргумент – self .


**5 слайд** - Классы

Простейший класс показан в следующем примере

Мы создаём новый класс при помощи оператора class и имени класса. За
этим следует блок выражений, формирующих тело класса. В данном случае
блок у нас пуст, на что указывает оператор pass .
Далее мы создаём объект-экземпляр класса, записывая имя класса со скобка-
ми. Для проверки мы
выясняем тип переменной, просто выводя её на экран. Так мы видим, что у
нас есть экземпляр класса Satellite в модуле __main__ .

Обратите внимание, что выводится также и адрес в памяти компьютера, где
хранится ваш объект. На вашем компьютере адрес будет другим, так как
Python хранит объекты там, где имеется свободное место.


**6 cлайд** - Методы объектов

Итак, мы выяснили что классы/объекты могут иметь методы, представляющие собой
функции, за исключением дополнительной переменной self . А теперь давайте рассмот-
рим пример. Здесь мы видим self в действии. Обратите внимание, что метод get_work_mode не
принимает параметров, но тем не менее, имеет self в определении функции.

Метод get_work_mode необходим для получения текущего режима работы спутника. Пока он только выводит статический текст.


**7 слайд** - Метод __init__

Существует много методов, играющих специальную роль в классах Python. Сейчас мы
увидим значительность метода __init__ .
Метод __init__ запускается, как только объект класса реализуется. Этот метод полезен
для осуществления разного рода инициализации, необходимой для данного объекта. Об-
ратите внимание на двойные подчёркивания в начале и в конце имени.

Здесь мы определяем метод __init__ так, чтобы он принимал параметр name, work_mode
(наряду с обычным self ). Далее мы создаём новое поле с именем name и с именем work_mode . Если взять в пример переменную name, об-
ратите внимание, что это две разные переменные, даже несмотря на то, что
они обе названы name . Это не проблема, так как точка в выражении self.
name обозначает, что существует нечто с именем «name», являющееся частью
объекта «self», и другое name – локальная переменная. Поскольку мы в явном
виде указываем, к которому имени мы обращаемся, путаницы не возникнет.

Для создания нового экземпляра unisat класса Satellite мы указываем имя класса,
после которого – аргументы в скобках: unisat = Satellite('unisat', 'активен') .
Метод __init__ мы при этом не вызываем явным образом. В этом и заклю-
чается специальная роль данного метода.
После этого мы получаем возможность использовать поле self.work_mode в наших
методах, что и продемонстрировано в методе get_work_mode .


**8 слайд** - Переменные класса и объекта

Функциональную часть классов и объектов (т.е. методы) мы обсудили, теперь давайте
ознакомимся с частью данных. Данные, т.е. поля, являются не чем иным, как обычны-
ми переменными, заключёнными в пространствах имён классов и объектов. Это означа-
ет, что их имена действительны только в контексте этих классов или объектов. Отсюда и
название «пространство имён».
Существует два типа полей: переменные класса и переменные объекта, которые разли-
чаются в зависимости от того, принадлежит ли переменная классу или объекту соответ-
ственно.
Переменные класса разделяемы – доступ к ним могут получать все экземпляры этого клас-
са. Переменная класса существует только одна, поэтому когда любой из объектов изме-
няет переменную класса, это изменение отразится и во всех остальных экземплярах того
же класса.
Переменные объекта принадлежат каждому отдельному экземпляру класса. В этом случае
у каждого объекта есть своя собственная копия поля, т.е. не разделяемая и никоим образом
не связанная с другими такими же полями в других экземплярах. Это легко понять на
примере

Это длинный пример, но он помогает продемонстрировать природу перемен-
ных класса и объекта. Здесь population принадлежит классу Robot , и поэто-
му является переменной класса. Переменная name принадлежит объекту (ей
присваивается значение при помощи self ), и поэтому является переменной
объекта.
Таким образом, мы обращаемся к переменной класса active_satellites как Satellite.active_satellites , а не self.active_satellites . К переменной же объекта name во всех методах этого объекта мы обращаемся при помощи обозначения self.name .
Помните об этой простой разнице между переменными класса и объекта. Так-
же имейте в виду, что переменная объекта с тем же именем, что и переменная
класса, сделает недоступной («спрячет») переменную класса!

Помните, что к переменным и методам самого объекта нужно обращаться, пользуясь
только self . Это называется доступом к атрибутам.

**9 слайд** - Наследование

Одно из главных достоинств объектно-ориентированного программирования заключа-
ется в многократном использовании одного и того же кода, и один из способов этого
достичь – при помощи механизма наследования. Легче всего представить себе наследова-
ние в виде отношения между классами как тип и подтип.

Давайте представим, что нам необходимо создать новый класс Нано-спутник. У него будут такие же атрибуты и методы, как и у класса Спутник. Конечно мы можем создат ь независимый класс и работать с ним, но тогда добавление какой-либо новой общей характеристики потребует добавления ее к каждому из этих независимых классов по отдельности, что делает программу неповоротливой. 

  Лучше создать общий класс с именем Satellite , а затем сделать так, чтобы класс NanoSatellite наследовал этот класс, т.е. чтобы он стал подтипом этого
типа (класса), после чего добавить любые специфические характеристики к этому подтипу.

У такого подхода есть множество достоинств. Если мы добавим/изменим какую-либо
функциональность в Satellite , это автоматически отобразится и во всех подтипах.
Например, мы можем добавить новое поле температуры или скорости, просто добавив его к классу Satellite . С другой стороны, изменения в подтипах
никак не влияют на другие подтипы. Ещё одно достоинство состоит в том, что обращать-
ся к объекту наноспутника можно как к объекту спутника , что может
быть полезно в ряде случаев, например, если у нас имеются и другие типы спутников. Когда подтип может быть подставлен в любом месте, где ожидается родительский тип, т.е. объект считается экземпляром родительского класса, это называется полиморфизмом.
Заметьте также, что код родительского класса используется многократно, и нет необходи-
мости копировать его во все классы, как пришлось бы в случае использования независи-
мых классов.
Класс Satellite в этой ситуации называют базовым классом или надклассом, класс NanoSatellite называют производным классом или подклассом.

