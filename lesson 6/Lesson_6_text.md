## Lesson 6

Курс по программированию на языке Python 

**3 слайд**- Структуры данных

Добрый день. Сегодняшняя тема - структуры данных.

Структуры данных – это, по сути, и есть структуры, которые могут хранить некоторые
данные вместе. Другими словами, они используются для хранения связанных данных.

В Python существуют четыре встроенных структуры данных: списоки - list, словари - dictionary или dict, кортежи - tuple, и
множества - set. Посмотрим, как ими пользоваться, и как они могут облегчить нам жизнь.

**4 слайд** - Список

Список – это структура данных, которая содержит упорядоченный набор элементов, т.е.
хранит последовательность элементов. Это легко представить, если вспомнить список по-
купок, в котором перечисляется, что нужно купить, с тем лишь исключением, что в списке
покупок каждый элемент обычно размещается на отдельной строке, тогда как в Python
они разделяются запятыми.

Список элементов должен быть заключён в квадратные скобки, чтобы Python понял, что
это список. Как только список создан, можно добавлять, удалять или искать элементы
в нём. Поскольку элементы можно добавлять и удалять, мы говорим, что список – это
изменяемый тип данных, т.е. его можно модифицировать.

Рассмотрим методы списков:
1) list.append(x) - Добавление элемента в список
2) list.clear() - Удаляет все элементы из списка
3) list.insert(i, x) - Вставляет элемент по индексу
4) list.pop(i) - Возвращает элемент, удаляя его
5) list.sort() - Сортирует список

И так далее...

**Переход к коду**

Переменная shoplist – это список покупок человека, идущего на рынок. В
shoplist мы храним только строки с названиями того, что нужно купить,
однако в список можно добавлять любые объекты, включая числа или даже
другие списки.
Мы также использовали цикл for..in для итерации по элементам списка.
Вы уже, наверное, поняли, что список является также и последовательностью.
Особенности последовательностей будут рассмотрены ниже.

Далее мы добавляем элемент к списку при помощи append – метода объекта
списка. Затем мы проверяем, действительно
ли элемент был добавлен к списку, выводя содержимое списка на экран при
помощи простой передачи этого списка функции print , которая аккуратно
его печатает.
Затем мы сортируем список, используя метод sort объекта списка. Имейте в
виду, что этот метод действует на сам список, а не возвращает изменённую его
версию. Именно это имеется в виду, когда мы говорим, что списки изменяемы, а строки – неиз-
меняемы.
Далее после совершения покупки мы хотим удалить её из списка. Это дости-
гается применением оператора del . Мы указываем, какой элемент списка мы
хотим удалить, и оператор del удаляет его. Мы указываем, что хотим удалить
первый элемент списка, и поэтому пишем « del shoplist[0] » (помните, что
Python начинает отсчёт с 0).

**6 cлайд** - Кортеж 

Кортежи служат для хранения нескольких объектов вместе. Их можно рассматривать как
аналог списков, но без такой обширной функциональности, которую предоставляет класс
списка. Одна из важнейших особенностей кортежей заключается в том, что они неизме-
няемы, так же, как и строки. Т.е. модифицировать кортежи невозможно.
Кортежи обозначаются указанием элементов, разделённых запятыми; по желанию их
можно ещё заключить в круглые скобки.
Кортежи обычно используются в тех случаях, когда оператор или пользовательская функ-
ция должны наверняка знать, что набор значений, т.е. кортеж значений, не изменится.

Картинка зоопарка здесь приведена не просто так.

**Переход к коду**
Переменная zoo обозначает кортеж элементов. Как мы видим, функция len
позволяет получить длину кортежа. Это также указывает на то, что кортеж
является последовательностью.
Теперь мы перемещаем этих животных в новый зоопарк, поскольку старый
зоопарк закрывается. Поэтому кортеж new_zoo содержит тех животных, ко-
торые уже там, наряду с привезёнными из старого зоопарка. Возвращаясь к
реальности, обратите внимание на то, что кортеж внутри кортежа не теряет
своей индивидуальности. Доступ к элементам кортежа осуществляется указанием позиции элемента,
заключённой в квадратные скобки – точно так же, как мы это делали для спис-
ков. Это называется оператором индексирования. Доступ к третьему элементу
в new_zoo мы получаем, указывая new_zoo[2] , а доступ к третьему элементу
внутри третьего элемента в кортеже new_zoo – указывая new_zoo[2][2] . Это
достаточно просто, как только вы поймёте принцип.

**9 слайд** - Последовательности

Списки, кортежи и строки являются примерами последовательностей. Но что такое по-
следовательности и что в них такого особенного?
Основные возможности – это проверка принадлежности (т.е. выражения « in » и « not
in ») и оператор индексирования, позволяющий получить напрямую некоторый эле-
мент последовательности.

Все три типа последовательностей, упоминавшиеся выше (списки, кортежи и строки),
также предоставляют операцию получения вырезки, которая позволяет получить вырез-
ку последовательности, т.е. её фрагмент.

Прежде всего, мы видим, как использовать индексы для получения отдельных
элементов последовательности. Это ещё называют приписыванием индекса. Ко-
гда мы указываем число в квадратных скобках после последовательности, как
показано выше, Python извлекает элемент, соответствующий указанной пози-
ции в последовательности. Помните, что Python начинает отсчёт с 0. Поэтому
shoplist[0] извлекает первый элемент, а shoplist[3] – четвёртый элемент
последовательности shoplist .
Индекс также может быть отрицательным числом. В этом случае позиция от-
считывается от конца последовательности. Поэтому shoplist[-1] указывает
на последний элемент последовательности shoplist , а shoplist[-2] – на
предпоследний.
Операция вырезки производится при помощи указания имени последова-
тельности, за которым может следовать пара чисел, разделённых двоеточием
и заключённых в квадратные скобки. Заметьте, как это похоже на операцию
индексирования, которой мы пользовались до сих пор. Помните, что числа в
скобках необязательны, тогда как двоеточие – обязательно.
Первое число (перед двоеточием) в операции вырезки указывает позицию, с
которой вырезка должна начинаться, а второе число (после двоеточия) указы-
вает, где вырезка должна закончиться. Если первое число не указано, Python
начнёт вырезку с начала последовательности. Если пропущено второе число,
Python закончит вырезку у конца последовательности. Обратите внимание,
что полученная вырезка будет начинаться с указанной начальной позиции,
а заканчиваться прямо перед указанной конечной позицией, т.е. начальная
позиция будет включена в вырезку, а конечная – нет.
Таким образом, shoplist[1:3] возвращает вырезку из последовательности,
начинающуюся с позиции 1, включает позицию 2, но останавливается на
позиции 3, и поэтому возвращает вырезку из двух элементов. Аналогично,
shoplist[:] возвращает копию всей последовательности.
Вырезка может осуществляться и с отрицательными значениями. Отрицательные числа
обозначают позицию с конца последовательности. Например,
shoplist[:-1] вернёт вырезку из последовательности, исключающую по-
следний элемент, но содержащую все остальные.


**7 слайд** - Словарь

Словарь – это некий аналог адресной книги, в которой можно найти адрес или контакт-
ную информацию о человеке, зная лишь его имя; т.е. некоторые ключи (имена) связаны
со значениями (информацией). Заметьте, что ключ должен быть уникальным – вы ведь
не сможете получить корректную информацию, если у вас записаны два человека с пол-
ностью одинаковыми именами.
Обратите также внимание на то, что в словарях в качестве ключей могут использоваться
только неизменяемые объекты (как строки), а в качестве значений можно использовать
как неизменяемые, так и изменяемые объекты. Точнее говоря, в качестве ключей должны
использоваться только простые объекты.

Пары ключ-значение указываются в словаре следующим образом: « d = {key1 :
value1, key2 : value2 } ». Обратите внимание, что ключ и значение разделяются
двоеточием, а пары друг от друга отделяются запятыми, а затем всё это заключается в
фигурные скобки.
Помните, что пары ключ-значение никоим образом не упорядочены в словаре. Если вам
необходим некоторый порядок, вам придётся отдельно отсортировать словарь перед об-
ращением к нему.

Рассмотрим методы словарей:
1) dict.keys()- Возвращает ключи из словаря
2) dict.clear()- Очищает словарь
3) dict.items()- Возвращает кортеж (ключ, значение)
4) dict.popitem()- Возвращает элемент, удаляя его
5) dict.values()- Возвращает значения из словаря​

**Переход к коду** 

Мы создаём словарь params при помощи обозначений, описанных ранее. Затем
мы обращаемся к парам ключ-значение, указывая ключ в операторе индек-
сирования, которым мы пользовались для списков и кортежей. Как видите,
синтаксис прост.
Удалять пары ключ-значение можно при помощи нашего старого доброго
оператора del . Мы просто указываем имя словаря и оператор индексирования
для удаляемого ключа, после чего передаём это оператору del . Для этой опе-
рации нет необходимости знать, какое значение соответствует данному клю-
чу.
Далее мы обращаемся ко всем парам ключ-значение нашего словаря, исполь-
зуя метод items , который возвращает список кортежей, каждый из которых
содержит пару элементов: ключ и значение. Мы получаем эту пару и при-
сваиваем её значение переменным name и parameter соответственно в цикле
for..in , а затем выводим эти значения на экран в блоке for.
Новые пары ключ-значение добавляются простым обращением к нужному
ключу при помощи оператора индексирования и присваиванием ему неко-
торого значения, как мы сделали для режима записи видео в примере выше.
Проверить, существует ли пара ключ-значение, можно при помощи оператора
in.


**10 слайд** - Множество

Множества – это неупорядоченные наборы простых объектов. Они необходимы тогда, ко-
гда присутствие объекта в наборе важнее порядка или того, сколько раз данный объект
там встречается.
Используя множества, можно осуществлять проверку принадлежности, определять, яв-
ляется ли данное множество подмножеством другого множества, находить пересечения
множеств и так далее.

Рассмотрим методы множеств:
1) set.add(x) - добавляет элемент в множество
2) set.remove(x) - удаляет элемент из множества
3) set.issubset(other) - Все элементы set принадлежат other
4) set.union(other, ...) - Объединение нескольких множеств
5) set.intersection(other, ...) - Пересечение нескольких множеств

И так далее...

**Переход к коду**

Рассмотрим множества. Пускай мы имеем множество bri, которое инициализируется путем преобразования списка из трех элементов('Бразилия', 'Россия' и 'Индия'), с использованием функции set(). То есть set - это множество. Как вы знаете мы можем проверить наличие элемента в нашем set-e. Для этого мы используем условный оператор if, и оператор in. Если 'Индия' есть в нашем множестве, то мы выведем данное сообщение. Если его нет, то выведем сообщение, что его нет в множестве. Давайте запустим наш код, и как вы видите "Индия" есть в нашем множестве. Давайте проверим, есть ли "США" в нашем множестве. Как это видно на глаз, "США" не является членом нашего множества, поэтому мы выводим наше сообщение из блока else. То есть "США нет в множестве". Затем с помощью метода copy() мы може скопировать наше множество в отдельную переменную. После этого, для добавления нового элемента в наше множество мы используем метод add(). То есть мы можем добавить в скопированное множество слово "Китай". Для проверки, является ли множество подмножеством другого множества, мы используем метод issuperset(). Давайте выведем его. И как вы видите - "True". Для того, чтобы удалить элемент из нашего множества, мы используем метод remove().Давайте так же выведем полученное множество, 
то есть в нашем множестве bri осталось всего 2 страны - это "Бразилия" и "Индия". В конечно итоге метод intersection() показывает нам пересечение множеств. То есть мы берем множества bri и bric и с помощью данного метода выбираем элементы, которые есть и в том, и в том множестве.

