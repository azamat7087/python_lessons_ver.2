## Lesson 6

Курс по программированию на языке Python 

**3 слайд**- Структуры данных

Добрый день. Сегодняшняя тема - структуры данных.

Структуры данных – это, по сути, и есть структуры, которые могут хранить некоторые
данные вместе. Другими словами, они используются для хранения связанных данных.

В Python существуют четыре встроенных структуры данных: список, кортеж, словарь и
множество. Посмотрим, как ими пользоваться, и как они могут облегчить нам жизнь.

**4 слайд** - Список

Список – это структура данных, которая содержит упорядоченный набор элементов, т.е.
хранит последовательность элементов. Это легко представить, если вспомнить список по-
купок, в котором перечисляется, что нужно купить, с тем лишь исключением, что в списке
покупок каждый элемент обычно размещается на отдельной строке, тогда как в Python
они разделяются запятыми.

Список элементов должен быть заключён в квадратные скобки, чтобы Python понял, что
это список. Как только список создан, можно добавлять, удалять или искать элементы
в нём. Поскольку элементы можно добавлять и удалять, мы говорим, что список – это
изменяемый тип данных, т.е. его можно модифицировать.

**5 слайд** - Работа со списками

Переменная shoplist – это список покупок человека, идущего на рынок. В
shoplist мы храним только строки с названиями того, что нужно купить,
однако в список можно добавлять любые объекты, включая числа или даже
другие списки.
Мы также использовали цикл for..in для итерации по элементам списка.
Вы уже, наверное, поняли, что список является также и последовательностью.
Особенности последовательностей будут рассмотрены ниже.

Далее мы добавляем элемент к списку при помощи append – метода объекта
списка. Затем мы проверяем, действительно
ли элемент был добавлен к списку, выводя содержимое списка на экран при
помощи простой передачи этого списка функции print , которая аккуратно
его печатает.
Затем мы сортируем список, используя метод sort объекта списка. Имейте в
виду, что этот метод действует на сам список, а не возвращает изменённую его
версию. Именно это имеется в виду, когда мы говорим, что списки изменяемы, а строки – неиз-
меняемы.
Далее после совершения покупки мы хотим удалить её из списка. Это дости-
гается применением оператора del . Мы указываем, какой элемент списка мы
хотим удалить, и оператор del удаляет его. Мы указываем, что хотим удалить
первый элемент списка, и поэтому пишем « del shoplist[0] » (помните, что
Python начинает отсчёт с 0).

Давайте рассмотрим работу со списками на реальном примере. Пускай мы имеем список parameters, в котором находятся: ускорение, радиация, время, дистанция. Запустим наш код и будем потихоньку разбирать каждый метод. В самом начале нам необходимо вывести количество элементов в нашей последовательности, в нашем списке. Для этого мы будем применять метод len, то есть length. Вызываем функцию print с текстом "Спутник предоставляет нам", вызывается функция len с аргументом parameters и последняя строка параметра. Таким образом мы выводим строку "спутник предоставляет нам 4 параметра". То есть в нашем списке parameters 4 элемента. Затем необходимо вывести каждый параметр из даного списка. Для этого мы создаем цикл for...in и обращаемся к каждому элементу в нашей последовательности. И выводим его на экран. Здесь мы вывели ускорение, радиация, время, дистанция, с новой строки. Теперь нам необходимо добавить новый параметр в наш список. Как я говорил ранее, мы используем метод append для подобных операций. То есть мы проводим команду parameters.append("температура"). И теперь наш список является таковым, что кроме 4 основынх элементов мы также имеем новый элемент температура. Далее нам нужно отсортировать список в алфавитном порядке. Для этого применяем метод sort. Затем выводим отсортированный список. То есть сперва идет время, затем дистанция, радиация, температура и ускорение. Далее при помощи индекса мы можем вывести любой элемент из нашего списка. В данном случае мы выведем первый элемент с помощью индекса 0. Это у нас - время. Теперь нам нужно удалить данный элемент из нашего списка. Для этого мы применяем оператор del и элемент, который нам нужно удалить, то есть parameters и его индекс - 0. В конечном итоге, мы выводим, что удалили параметр-время из списка и чтобы доказать, что операция прошла успешно, мы показываем наш список параметров. Как вы заметили здесь снова 4 элемента: дистанция, радиация, температура и ускорение. 
**6 cлайд** - Кортеж 

Кортежи служат для хранения нескольких объектов вместе. Их можно рассматривать как
аналог списков, но без такой обширной функциональности, которую предоставляет класс
списка. Одна из важнейших особенностей кортежей заключается в том, что они неизме-
няемы, так же, как и строки. Т.е. модифицировать кортежи невозможно.
Кортежи обозначаются указанием элементов, разделённых запятыми; по желанию их
можно ещё заключить в круглые скобки.
Кортежи обычно используются в тех случаях, когда оператор или пользовательская функ-
ция должны наверняка знать, что набор значений, т.е. кортеж значений, не изменится.

Переменная zoo обозначает кортеж элементов. Как мы видим, функция len
позволяет получить длину кортежа. Это также указывает на то, что кортеж
является последовательностью.
Теперь мы перемещаем этих животных в новый зоопарк, поскольку старый
зоопарк закрывается. Поэтому кортеж new_zoo содержит тех животных, ко-
торые уже там, наряду с привезёнными из старого зоопарка. Возвращаясь к
реальности, обратите внимание на то, что кортеж внутри кортежа не теряет
своей индивидуальности. Доступ к элементам кортежа осуществляется указанием позиции элемента,
заключённой в квадратные скобки – точно так же, как мы это делали для спис-
ков. Это называется оператором индексирования. Доступ к третьему элементу
в new_zoo мы получаем, указывая new_zoo[2] , а доступ к третьему элементу
внутри третьего элемента в кортеже new_zoo – указывая new_zoo[2][2] . Это
достаточно просто, как только вы поймёте принцип.

Рассмотрим работу с кортежами на реальном примере. В данном случае, мы имеем кортеж zoo, наш зоопарк. В нем есть 3 элемента: питон, слон и пингвин. Так же нужно помнить, что скобки являются необязательными. Для начала запустим наш код. Первая функция print выводит нам количество животных в зоопарке, а их у нас 3 штуки. Затем с помощью новой переменной newzoo мы инициализируем новый кортеж, в котором содержатся обезьяна, верблюд и наш старый зоопарк. В выводе нам четко видно, что 3 элементом нашего кортежа является другой кортеж. Выведем животных привезенных из старого зоопарка. Для этого мы обращаемся к 3 элементу с индексом 2, опять же напомним, что в python отсчет начинается с нуля.  После этого, нам нужно вывести последнее животное, привезенное из старого зоопарка. Для этого мы обращаемся к 3 элементу нашей последовательности - это кортеж, а внутри него обращаемся к 3 элементу данного кортежа.  То есть new_zoo[2][2]. Таким образом мы понимаем, что последнее животное привезенное из старого зоопарка, это пингвин. А теперь нам необходимо вывести полное количество животных в новом зоопарке. Для этого мы берем размер нашего нового зоопарка, отнимаем из него единицу, так как один из элементов является кортежем. Затем выводим размер 3 элемента нашего кортежа, то есть старого зоопарка. И таким образом логически можно понять, что 2 + 3 равно 5. 


**7 слайд** - Словарь

Словарь – это некий аналог адресной книги, в которой можно найти адрес или контакт-
ную информацию о человеке, зная лишь его имя; т.е. некоторые ключи (имена) связаны
со значениями (информацией). Заметьте, что ключ должен быть уникальным – вы ведь
не сможете получить корректную информацию, если у вас записаны два человека с пол-
ностью одинаковыми именами.
Обратите также внимание на то, что в словарях в качестве ключей могут использоваться
только неизменяемые объекты (как строки), а в качестве значений можно использовать
как неизменяемые, так и изменяемые объекты. Точнее говоря, в качестве ключей должны
использоваться только простые объекты.

Пары ключ-значение указываются в словаре следующим образом: « d = {key1 :
value1, key2 : value2 } ». Обратите внимание, что ключ и значение разделяются
двоеточием, а пары друг от друга отделяются запятыми, а затем всё это заключается в
фигурные скобки.
Помните, что пары ключ-значение никоим образом не упорядочены в словаре. Если вам
необходим некоторый порядок, вам придётся отдельно отсортировать словарь перед об-
ращением к нему.



**8 слайд** - Работа со словарями

Мы создаём словарь ab при помощи обозначений, описанных ранее. Затем
мы обращаемся к парам ключ-значение, указывая ключ в операторе индек-
сирования, которым мы пользовались для списков и кортежей. Как видите,
синтаксис прост.
Удалять пары ключ-значение можно при помощи нашего старого доброго
оператора del . Мы просто указываем имя словаря и оператор индексирования
для удаляемого ключа, после чего передаём это оператору del . Для этой опе-
рации нет необходимости знать, какое значение соответствует данному клю-
чу.
Далее мы обращаемся ко всем парам ключ-значение нашего словаря, исполь-
зуя метод items , который возвращает список кортежей, каждый из которых
содержит пару элементов: ключ и значение. Мы получаем эту пару и при-
сваиваем её значение переменным name и address соответственно в цикле
for..in , а затем выводим эти значения на экран в блоке for.
Новые пары ключ-значение добавляются простым обращением к нужному
ключу при помощи оператора индексирования и присваиванием ему неко-
торого значения, как мы сделали для Guido в примере выше.
Проверить, существует ли пара ключ-значение, можно при помощи оператора
in.

Давайте рассмотрим работу со словарями. Мы имеем словарь параметров parameters_ dictionary, в котором ключами являются названия наших параметров, а значениями их значения. То есть, speed имеет значение 36,  work_mode(рабочее состояние) - активное, температура - 0, а так же количество камер - 3. Для того, чтобы получить элемент из нашего словаря, то есть его значение, нам необходимо ввести его ключ. Для этого мы выбираем наш словарь и с помощью квадратных скобок вносим в него ключ. Таким образом мы получаем его значение. Как вы видите в первом примере мы вывели значение температуры - оно равно 0. Удалить какую-либо пару из нашего словаря можно при помощи оператора del. Для этого мы вызываем наш элемент из словаря, путем ввода ключа. Для того, чтобы проверить провели ли мы правильно операцию удаления, мы можем вывести количество элементов в нашем словаре. Для этого с помощью метода format мы получаем количество элементов в словаре параметров. И как вы видите в нашем словаре 3 параметра.  Мы удалили параметр Temp, до этого их было 4. Затем нам нужно пройтись по элементам нашего словаря. Для этого мы вызваем метод items(), который нам вернет кортеж, как я говорил ранее. Эти элементы в кортеже мы присваиваем значения переменным name и value. И опять же с помощью метода format мы можем вывести значения этих переменных в нашей строке. Параметр speed имеет значение 36, параметр work _mode имеет значение active и так далее. Затем мы можем добавлять новые ключ-значения в наш словарь. Для этого нужно ввести ключ, которого в нашем словаре нет и затем присвоить ему значение. Если данный ключ уже имеется в нашем словаре, то он просто переопределится, ему присвоится новое значение. Так же мы можем проверить, есть ли данный ключ в нашем словаре. Для этого мы применяем оператор in, и как вы видите ключ Time в нашем словаре есть и в случае истинности данного выражения мы выводим значение текущего времени полета. И текущее время полета равно 22 часам или минутам. Пока это не важно.

**9 слайд** - Последовательности

Списки, кортежи и строки являются примерами последовательностей. Но что такое по-
следовательности и что в них такого особенного?
Основные возможности – это проверка принадлежности (т.е. выражения « in » и « not
in ») и оператор индексирования, позволяющий получить напрямую некоторый эле-
мент последовательности.

Все три типа последовательностей, упоминавшиеся выше (списки, кортежи и строки),
также предоставляют операцию получения вырезки, которая позволяет получить вырез-
ку последовательности, т.е. её фрагмент.

Прежде всего, мы видим, как использовать индексы для получения отдельных
элементов последовательности. Это ещё называют приписыванием индекса. Ко-
гда мы указываем число в квадратных скобках после последовательности, как
показано выше, Python извлекает элемент, соответствующий указанной пози-
ции в последовательности. Помните, что Python начинает отсчёт с 0. Поэтому
shoplist[0] извлекает первый элемент, а shoplist[3] – четвёртый элемент
последовательности shoplist .
Индекс также может быть отрицательным числом. В этом случае позиция от-
считывается от конца последовательности. Поэтому shoplist[-1] указывает
на последний элемент последовательности shoplist , а shoplist[-2] – на
предпоследний.
Операция вырезки производится при помощи указания имени последова-
тельности, за которым может следовать пара чисел, разделённых двоеточием
и заключённых в квадратные скобки. Заметьте, как это похоже на операцию
индексирования, которой мы пользовались до сих пор. Помните, что числа в
скобках необязательны, тогда как двоеточие – обязательно.
Первое число (перед двоеточием) в операции вырезки указывает позицию, с
которой вырезка должна начинаться, а второе число (после двоеточия) указы-
вает, где вырезка должна закончиться. Если первое число не указано, Python
начнёт вырезку с начала последовательности. Если пропущено второе число,
Python закончит вырезку у конца последовательности. Обратите внимание,
что полученная вырезка будет начинаться с указанной начальной позиции,
а заканчиваться прямо перед указанной конечной позицией, т.е. начальная
позиция будет включена в вырезку, а конечная – нет.
Таким образом, shoplist[1:3] возвращает вырезку из последовательности,
начинающуюся с позиции 1, включает позицию 2, но останавливается на
позиции 3, и поэтому возвращает вырезку из двух элементов. Аналогично,
shoplist[:] возвращает копию всей последовательности.
Вырезка может осуществляться и с отрицательными значениями. Отрицательные числа
обозначают позицию с конца последовательности. Например,
shoplist[:-1] вернёт вырезку из последовательности, исключающую по-
следний элемент, но содержащую все остальные.

Давайте рассмотрим операции индексирования и вырезки из нашего списка и строки.  Мы имеем список parameters, в котором 4 элемента, a так же строку name. Для начала рассмотрим операции индексирования. Как вы помните с помощью индекса вы можете извлекать элементы из списка или строки. Таким образом элемент 0 , это у нас parameters[0], что равен ускорению. Как вы видите здесь элемент 0 равен ускорение. Таким образом можно вывести все остальные элементы нашего списка. То есть радиацию, время, дистанцию. Так же индексы со знаком минус, значит, что мы берем элементы  с конца нашего списка или строки. Таким образом parameters[-1],  выведет нам дистанцию. А parameters[-2], выведет нам время. Давайте применим операторы индексирования к нашей строке. Из name[0] мы получаем - символ s. То есть это первый символ нашей строки. Далее рассмотрим вырезки из списка. Элементы с 1 по 3, не включая его, будут писаться следующим образом: parameters[1:3]. И мы выводим радиацию и время.  Элементы с индекса 2 и до конца, то есть 2:, и оставляем пустое место, то есть со второго до конца, это у нас время и дистанция. Так же элементы от 1 до -1 индекса - это у нас радиация и время. Так же мы можем вывести все элементы, поставив только двоеточие. Ну и двоеточие так же можно и не ставить. Теперь вырезки из строки, тоже самое мы можем применить к типу string, как вы знаете. То есть символ с 1 по 3, это у нас 'at' в слове 'satellite'. Со 2 до конца - 2: и пустое место. Ну и тоже самое, как и было со списками, только здесь мы уже выводим символы. 

**10 слайд** - Множество

Множества – это неупорядоченные наборы простых объектов. Они необходимы тогда, ко-
гда присутствие объекта в наборе важнее порядка или того, сколько раз данный объект
там встречается.
Используя множества, можно осуществлять проверку принадлежности, определять, яв-
ляется ли данное множество подмножеством другого множества, находить пересечения
множеств и так далее.

**11 слайд** - Работа с множествами

В данном примере мы создаем множество стран, путем преобразования списка стран, с помощью функции set().

Как говорилось ранее множества позволяют осуществлять проверку принадлежности объектов. И используя оператор in мы можем узнать есть ли "Индия" в нашем множестве.

Метод copy позволяет скопировать множество. 

Метод add добавляет элемент в нужное нам множество. 

Метод issuperset проверяет является ли данное множество подмножеством другого множества.

Метод remove позволяет удалить элемент из множества.

Метод intersection - пересечение множеств, возвращает нам элементы, которые находятся в обоих множествах.

Рассмотрим множества. Пускай мы имеем множество bri, которое инициализируется путем преобразования списка из трех элементов('Бразилия', 'Россия' и 'Индия'), с использованием функции set(). То есть set - это множество. Как вы знаете мы можем проверить наличие элемента в нашем set-e. Для этого мы используем условный оператор if, и оператор in. Если 'Индия' есть в нашем списке, то мы выведем данное сообщение. Если его нет, то выведем сообщение, что его нет в множестве. Давайте запустим наш код, и как вы видите "Индия" есть в нашем множестве. Давайте проверим, есть ли "США" в нашем множестве. Как это видно на глаз, "США" не является членом нашего множества, поэтому мы выводим наше сообщение из блока else. То есть "США нет в множестве". Затем с помощью метода copy() мы може скопировать наше множество в отдельную переменную. После этого, для добавления нового элемента в наше множество мы используем метод add(). То есть мы можем добавить в скопированное множество слово "Китай". Для проверки, является ли множество подмножеством другого множества, мы используем метод issuperset(). Давайте выведем его. И как вы видите - "True". Для того, чтобы удалить элемент из нашего множества, мы используем метод remove().Давайте так же выведем полученное множество, 
то есть в нашем множестве bri осталось всего 2 страны - это "Бразилия" и "Индия". В конечно итоге метод intersection() показывает нам пересечение множеств. То есть мы берем множества bri и bric и с помощью данного метода выбираем элементы, которые есть и в том, и в том множестве.

